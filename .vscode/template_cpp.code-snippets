{
	// Place your competition_cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"template for competition": {
		"prefix": "competition_template",
		"body": [
			"#if !defined(MAIN_CC)",
			"/* ========================================================================== */",
			"#define MAIN_CC",
			"/**",
			" * @brief main part of the program.",
			" */",
			"",
			"#include __FILE__",
			"// #define UPPERCASE_YESNO",
			"// #define LOWERCASE_YESNO",
			"",
			"namespace competition {",
			"/**",
			" * @brief edit functions here",
			" * @note include std::*",
			" */",
			"using namespace std;",
			"using vi = vec<i32>;",
			"using vl = vec<i64>;",
			"using vld = vec<ld>;",
			"using vvi = vec<vi>;",
			"",
			"void solve() {",
			"  // std::cout << std::fixed << std::setprecision(15);",
			"  ${0: // edit here}",
			"}",
			"",
			"};  // namespace competition",
			"",
			"signed main() {",
			"  std::cin.tie(nullptr);",
			"  std::ios::sync_with_stdio(false);",
			"  competition::solve();",
			"}",
			"/* ========================================================================== */",
			"/* ========================================================================== */",
			"#else  // MAIN_CC",
			"/**",
			" * @brief template",
			" * @note following lines are included by oneself.",
			" */",
			"",
			"#include <bits/stdc++.h>",
			"",
			"#define rep(i, n) for (std::size_t i = 0; i < ((std::size_t)(n)); ++i)",
			"#define all(x) std::begin(x), std::end(x)",
			"",
			"// alias",
			"using i8 = int8_t;",
			"using i16 = int16_t;",
			"using i32 = int32_t;",
			"using i64 = int64_t;",
			"",
			"#ifdef __GNUC__  // i128",
			"using i128 = __int128_t;",
			"std::istream& operator>>(std::istream& is, i128& val) {",
			"  std::string s;",
			"  is >> s;",
			"  val = 0;",
			"  for (std::size_t i = 1; i < std::size(s); ++i) val = val * 10 + (s[i] ^ 48);",
			"  if (s[0] == '-') val = -val;",
			"  return is;",
			"}",
			"std::ostream& operator<<(std::ostream& os, const i128& val) {",
			"  if (val == 0) return os << '0';",
			"  i128 t = val;",
			"  if (val < 0) {",
			"    os << '-';",
			"    t = -t;",
			"  }",
			"  std::string s = \"\";",
			"  while (t) {",
			"    s += (char)(t % 10 | 48);",
			"    t /= 10;",
			"  }",
			"  std::reverse(std::begin(s), std::end(s));",
			"  return os << s;",
			"}",
			"#endif           // __GNUC__",
			"",
			"// unsigned integer",
			"using u8 = uint8_t;",
			"using u16 = uint16_t;",
			"using u32 = uint32_t;",
			"using u64 = uint64_t;",
			"using usize = size_t;",
			"",
			"// floating point number",
			"using f32 = float;",
			"using f64 = double;",
			"using ld = long double;",
			"",
			"// alias for container",
			"template <class T>",
			"using vec = std::vector<T>;",
			"template <class T>",
			"using hset = std::unordered_set<T>;",
			"template <class T, class U>",
			"using hmap = std::unordered_map<T, U>;",
			"template <class T>",
			"using maxheap = std::priority_queue<T>;",
			"template <class T>",
			"using minheap = std::priority_queue<T, std::vector<T>, std::greater<T> >;",
			"",
			"// constants",
			"constexpr ld pi = M_PIf64x;",
			"constexpr i64 max64 = std::numeric_limits<i64>::max();",
			"constexpr i32 max32 = std::numeric_limits<i32>::max();",
			"constexpr i64 infll = max64 - 10 * 9;",
			"constexpr i32 inf = max32 - 10 * 9;",
			"",
			"// traits",
			"namespace traits {",
			"namespace internal {",
			"template <class T, std::ostream& os = std::cout>",
			"auto is_printable_impl(int)",
			"    -> decltype((os << std::declval<T&>()), std::true_type());",
			"template <class T>",
			"std::false_type is_printable_impl(...);",
			"",
			"template <class T>",
			"auto is_tuplelike_impl(int)",
			"    -> decltype(std::is_integral_v<decltype(std::tuple_size<T>::value)>,",
			"                std::is_integral_v<decltype(std::get<T>(std::declval<T&>()))>,",
			"                std::true_type());",
			"template <class T>",
			"std::false_type is_tuplelike_impl(...);",
			"",
			"template <class T>",
			"auto is_iterable_impl(int)",
			"    -> decltype(std::begin(std::declval<T&>()) != std::end(std::declval<T&>()),",
			"                ++std::declval<decltype(std::begin(std::declval<T&>()))&>(),",
			"                *std::begin(std::declval<T&>()), std::true_type());",
			"}  // namespace internal",
			"template <class T>",
			"using is_printable = decltype(internal::is_printable_impl<T>(0));",
			"template <class T>",
			"using is_tuplelike = decltype(internal::is_tuplelike_impl<T>(0));",
			"template <class T>",
			"using is_iterable = decltype(internal::is_iterable_impl<T>(0));",
			"}  // namespace traits",
			"",
			"// print",
			"namespace internal {",
			"template <class... Args>",
			"constexpr auto false_t = false;",
			"",
			"template <char separator, char end, class T>",
			"void print_boolean_impl(const T& obj, std::ostream& os = std::cout) {",
			"#ifdef UPPERCASE_YESNO",
			"  os << (obj ? \"YES\" : \"NO\") << end;",
			"#else",
			"#ifdef LOWERCASE_YESNO",
			"  os << (obj ? \"yes\" : \"no\") << end;",
			"#endif",
			"  os << (obj ? \"Yes\" : \"No\") << end;",
			"#endif",
			"}",
			"template <char separator, char end, std::size_t N = 0, class T>",
			"void print_tuplelike_impl(const T& obj, std::ostream& os = std::cout) {",
			"  if constexpr (N < std::tuple_size<T>::value) {",
			"    os << std::get<N>(obj)",
			"       << (N + 1 < std::tuple_size<T>::value ? separator : end);",
			"    print_tuplelike_impl<separator, end, N + 1>(obj, os);",
			"  }",
			"}",
			"template <char separator, char end, class Iterable>",
			"void print_iterable_impl(Iterable iterable, std::ostream& os = std::cout) {",
			"  auto iter = std::begin(iterable), last = std::end(iterable);",
			"  while (iter != last) os << *iter << (++iter != last ? separator : end);",
			"}",
			"}  // namespace internal",
			"template <char separator = ' ', char end = '\\n', class T>",
			"void print(const T& obj, std::ostream& os = std::cout) {",
			"  if constexpr (std::is_same<T, bool>::value) {",
			"    internal::print_boolean_impl<separator, end>(obj, os);",
			"  } else if constexpr (traits::is_printable<T>::value) {",
			"    os << obj << end;",
			"  } else if constexpr (traits::is_iterable<T>::value) {",
			"    internal::print_iterable_impl<separator, end>(obj, os);",
			"  } else if constexpr (traits::is_tuplelike<T>::value) {",
			"    internal::print_tuplelike_impl<separator, end>(obj, os);",
			"  } else if constexpr (internal::false_t<T>) {  // compile time assert",
			"    static_assert(internal::false_t<T>, \"incompatible type error in print()\");",
			"  }",
			"}",
			"",
			"// petit",
			"template <class T>",
			"auto makev(std::size_t n, const T& value) {",
			"  return std::vector<T>(n, value);",
			"}",
			"template <class... Args>",
			"auto makev(std::size_t n, Args... args) {",
			"  return std::vector<decltype(makev(args...))>(n, makev(args...));",
			"}",
			"",
			"template <class T, class U>",
			"inline bool chmax(T& a, const U& b) {",
			"  return (a < b ? (a = b) == b : false);",
			"}",
			"template <class T, class U>",
			"inline bool chmin(T& a, const U& b) {",
			"  return (a > b ? (a = b) == b : false);",
			"}",
			"",
			"#endif  // MAIN_CC",
			""
		],
		"description": "template for competition"
	},
	"template for class-file": {
		"prefix": "library_template_for_class",
		"body": [
			"// ${1:<Name>}",
			"// ${2:<short description>}",
			"// Verified : <url>",
			"",
			"// dependencies",
			"// <#include \"lib/hoge.hpp\">",
			"// <#include <bits/stdc++.h>>",
			"",
			"",
			"/* ${1:<Name>} */",
			"// ${2:<short description>}",
			"//",
			"// List of Member",
			"// param:",
			"// 1. <p>: <type>",
			"// function:",
			"// 1. <f>(<p>: <type>) -> <type>",
			"$0",
			""
		],
		"description": "template for class-file"
	},
	"template for function-file": {
		"prefix": "library_template_for_function",
		"body": [
			"// ${1:<Name>}",
			"// ${2:<short description>}",
			"// Verified : <url>",
			"",
			"// dependencies",
			"// <#include \"lib/hoge.hpp\">",
			"// <#include <bits/stdc++.h>>",
			"",
			"",
			"/* ${1:<Name>} */",
			"// ${2:<short description>}",
			"//",
			"// param:",
			"// 1. <p>: <type>",
			"// return:",
			"// <p>: <type>",
			"$0",
			""
		],
		"description": "template for function-file"
	}
}