{
	// Place your competition_cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"calculate GCD": {
		"prefix": "gcd",
		"body": [
		  "/* GCD (Greatest Common Divisor) */",
		  "// calculate GCD",
		  "//",
		  "int_fast64_t GCD(int_fast64_t a, int_fast64_t b) {",
		  "    return (b ? GCD(b, a%b) : a);",
		  "}",
		  ""
		],
		"description": "calculate GCD"
	},
	"calculate LCM": {
		"prefix": "lcm",
		"body": [
		  "/* LCM (Least Common Multiple) */",
		  "// calculate LCM",
		  "//",
		  "int_fast64_t LCM(int_fast64_t a, int_fast64_t b) {",
		  "    int_fast64_t g = GCD(a, b);",
		  "    return (a/g) * (b/g) * g;",
		  "}",
		  ""
		],
		"description": "calculate LCM"
	},
	"ModInt": {
		"prefix": "mod_int",
		"body": [
		  "/* ModInt */",
		  "// Operators",
		  "// +, -, *, /, =, ==, !=,",
		  "// +=, -=, *=, /=",
		  "//",
		  "template<std::int_fast64_t Mod>",
		  "class ModInt {",
		  "  public:",
		  "    using i64 = std::int_fast64_t;",
		  "    i64 val;",
		  "    // constructor",
		  "    constexpr ModInt(const i64 p=0) noexcept : val(p>=0 ? p%Mod : (Mod+(p%Mod))%Mod) {}",
		  "",
		  "    // std::cin, std::cout",
		  "    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) {",
		  "        return os << x.val;",
		  "    }",
		  "    friend std::istream &operator>>(std::istream &is, ModInt &x) {",
		  "        is >> x.val;",
		  "        x.val %= Mod;",
		  "        if(x.val < 0) x.val += Mod;  // <- 負数対応",
		  "        return is;",
		  "    }",
		  "",
		  "    //operator",
		  "    constexpr ModInt operator+(const ModInt b) const noexcept { return ModInt(*this) += b; }",
		  "",
		  "    constexpr ModInt operator-(const ModInt b) const noexcept { return ModInt(*this) -= b; }",
		  "",
		  "    constexpr ModInt operator*(const ModInt b) const noexcept { return ModInt(*this) *= b; }",
		  "",
		  "    constexpr ModInt operator/(const ModInt b) const noexcept { return ModInt(*this) /= b; }",
		  "",
		  "    constexpr ModInt operator-() const noexcept { return ModInt() - *this; }",
		  "",
		  "    constexpr bool operator==(const ModInt &b) const noexcept { return this->val == b.val; }",
		  "",
		  "    constexpr bool operator!=(const ModInt &b) const noexcept { return this->val != b.val; }",
		  "",
		  "    constexpr ModInt &operator=(const ModInt b) noexcept {",
		  "        val = b.val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator=(const i64 b) noexcept {",
		  "        val = ModInt<Mod>(b).val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator+=(const ModInt b) noexcept {",
		  "        if((val += b.val) >= Mod) val -= Mod;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator-=(const ModInt b) noexcept {",
		  "        if(val < b.val) val += Mod;",
		  "        val -= b.val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator*=(const ModInt b) noexcept {",
		  "        val = val * b.val % Mod;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator/=(ModInt b) noexcept {",
		  "        val *= b.inverse().val;",
		  "        val %= Mod;",
		  "        return *this;",
		  "    }",
		  "    // calc val^n",
		  "    constexpr  ModInt pow(i64 n) noexcept {",
		  "        ModInt res = 1, a = val;",
		  "        while(n > 0) {",
		  "            if(n & 1) res = res * a;",
		  "            a = a * a;",
		  "            n >>= 1;",
		  "        }",
		  "        return res;",
		  "    }",
		  "  private:",
		  "    constexpr ModInt inverse() noexcept {",
		  "        i64 m=Mod, u=1, v=0, t=1;",
		  "        while(m) {",
		  "            t = val/m;",
		  "            val -= t*m; std::swap(val,m);",
		  "            u -= t*v; std::swap(u,v);",
		  "        }",
		  "        return ModInt(u);",
		  "    }",
		  "};",
		  "const int mod = 1000000007;",
		  "// const int mod = 998244353;",
		  "using mint = ModInt<mod>;",
		  ""
		],
		"description": "ModInt"
	},
	"Binomial": {
		"prefix": "binomial",
		"body": [
		  "/* Binomial (mod) */",
		  "// ",
		  "class Binomial {",
		  "  public:",
		  "    Binomial(int MAX = 510000, int MOD = 1000000007): MAX(MAX), MOD(MOD)",
		  "    {",
		  "        fac.resize(MAX);",
		  "        finv.resize(MAX);",
		  "        inv.resize(MAX);",
		  "        // Build 'binomial-table'",
		  "        fac[0] = fac[1] = 1;",
		  "        finv[0] = finv[1] = 1;",
		  "        inv[1] = 1;",
		  "        for (int i = 2; i < MAX; i++){",
		  "            fac[i] = fac[i - 1] * i % MOD;",
		  "            inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
		  "            finv[i] = finv[i - 1] * inv[i] % MOD;",
		  "        }",
		  "    }",
		  "",
		  "    // calculate Binomial(n, k) % MOD",
		  "    long long calc(int n, int k){",
		  "        if (n < k) return 0;",
		  "        if (n < 0 || k < 0) return 0;",
		  "        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
		  "    }",
		  "",
		  "  private:",
		  "    const int MAX;",
		  "    const int MOD;",
		  "    std::vector<long long> fac, finv, inv;",
		  "};",
		  ""
		],
		"description": "Binomial"
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve_of_eratosthenes",
		"body": [
		  "/* Sieve of Eratosthenes */",
		  "// detect prime numbers lower than MAX_N",
		  "// time complexity : O(N loglogN)",
		  "//",
		  "// Methods",
		  "// 1. is_prime(i64 n) -> bool : judge whether n is prime number",
		  "//",
		  "// Example",
		  "// constexpr size_t n = 1e7;",
		  "// Sieve<n> sieve; sieve.is_prime(157);",
		  "//",
		  "template<size_t MAX_N>",
		  "class Sieve {",
		  "  public:",
		  "    using i64 = int_fast64_t;",
		  "",
		  "    constexpr Sieve(): container() {",
		  "        for(i64 i = 1; i < (MAX_N+11)/6; ++i) {",
		  "            container[i][0] = container[i][1] = true;",
		  "        }",
		  "",
		  "        for(i64 i = 1; i < (MAX_N+11)/6; ++i) {",
		  "            if(container[i][0]) {  // 6i - 1 is prime",
		  "                for(i64 p = 1; p < (MAX_N+11)/6; ++p) {",
		  "                    i64 idx1 = 6*i*p + i - p;",
		  "                    i64 idx2 = 6*i*p - i - p;",
		  "                    if(idx2 >= (MAX_N+11)/6) break;",
		  "                    container[idx2][1] = false;",
		  "                    if(idx1 >= (MAX_N+11)/6) continue;",
		  "                    container[idx1][0] = false;",
		  "                }",
		  "            }",
		  "            if(container[i][1]) {  // 6i + 1 is prime",
		  "                for(i64 p = 1; p < (MAX_N+11)/6; ++p) {",
		  "                    i64 idx1 = 6*i*p + i + p;",
		  "                    i64 idx2 = 6*i*p - i + p;",
		  "                    if(idx2 >= (MAX_N+11)/6) break;",
		  "                    container[idx2][0] = false;",
		  "                    if(idx1 >= (MAX_N+11)/6) continue;",
		  "                    container[idx1][1] = false;",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    bool is_prime(i64 num) {  // num > 0",
		  "        if(num == 2 || num == 3) return true;",
		  "        if((num+1)%6 == 0) return (container[(num+1)/6][0]);",
		  "        if((num-1)%6 == 0) return (container[(num-1)/6][1]);",
		  "        return false;",
		  "    }",
		  "",
		  "  private:",
		  "    bool container[(MAX_N+11)/6][2];",
		  "};",
		  ""
		],
		"description": "Sieve of Eratosthenes"
	},
	"Prime Factorization": {
		"prefix": "prime_factorization",
		"body": [
		  "/* Prime Factorization */",
		  "// time complexity : O(sqrtN)",
		  "template<typename T_n>",
		  "std::map<T_n, int> prime_factor(T_n n) {",
		  "    std::map<T_n, int> ret;",
		  "    for(T_n i = 2; i*i <= n; i++){",
		  "        while(n % i == 0){",
		  "            ret[i]++;",
		  "            n /= i;",
		  "        }",
		  "    }",
		  "    if(n != 1) ret[n] = 1;",
		  "    return ret;",
		  "}",
		  "",
		  "/* Prime Factorization with preprocessing */",
		  "// time complexity (preprocessing) : O(N loglogN)",
		  "// time complexity (query) : O(logN)",
		  "template<size_t MAX_N>",
		  "class PrimeFactorization {",
		  "  public:",
		  "    using i64 = int_fast64_t;",
		  "    constexpr PrimeFactorization()",
		  "        : smallest_prime_factors() {",
		  "        for(i64 i = 0; i <= MAX_N; ++i) {",
		  "            smallest_prime_factors[i] = i;",
		  "        }",
		  "        for(i64 i = 2; i * i <= MAX_N; ++i) {",
		  "            if(smallest_prime_factors[i] == i) {",
		  "                for(i64 j = i * i; j <= MAX_N; j += i) {",
		  "                    if(smallest_prime_factors[j] == j) {",
		  "                        smallest_prime_factors[j] = i;",
		  "                    }",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    std::map<i64, i64> factorize(i64 n) {",
		  "        std::map<i64, i64> primes_map;",
		  "        while(n != 1) {",
		  "            ++primes_map[smallest_prime_factors[n]];",
		  "            n /= smallest_prime_factors[n];",
		  "        }",
		  "        return primes_map;",
		  "    }",
		  "  private:",
		  "    int_fast64_t smallest_prime_factors[MAX_N+1];",
		  "};",
		  ""
		],
		"description": "Prime Factorization"
	},
	"judge whether n is prime number or not": {
		"prefix": "is_prime",
		"body": [
		  "/* prime number judge */",
		  "// judge whether n is prime number or not",
		  "//",
		  "// Parameters",
		  "// 1. n (i32) : integer to be estimated",
		  "// ",
		  "// Returns",
		  "// 1. (bool) : is n prime number?",
		  "//",
		  "bool is_prime(int_fast32_t n) {",
		  "    if (n < 2) return false;",
		  "    else if (n == 2) return true;",
		  "    else if (n % 2 == 0) return false;",
		  "",
		  "    int_fast32_t sqrt_n = sqrt(n);",
		  "    for (int_fast32_t i = 3; i <= sqrt_n; i += 2){",
		  "        if (n % i == 0) return false;",
		  "    }",
		  "",
		  "    return true;",
		  "}",
		  ""
		],
		"description": "judge whether n is prime number or not"
	},
	"enumerate divisors of n": {
		"prefix": "enumerate_divisors",
		"body": [
		  "/* enumerate divisors */",
		  "// enumerate divisors of n",
		  "// time complexity : O(sqrtN)",
		  "//",
		  "// Parameters",
		  "// 1. n (i64) : targeted integer",
		  "// ",
		  "// Returns",
		  "// 1. divisors (vec<i64>) : divisors of n",
		  "//",
		  "std::vector<int_fast64_t> enumerate_divisors(int_fast64_t n) {",
		  "    std::vector<int_fast64_t> divisors;",
		  "    for (int_fast64_t i = 1; i * i <= n; i++) {",
		  "        if (n % i == 0) {",
		  "            divisors.push_back(i);",
		  "            if (i * i != n) divisors.push_back(n / i);",
		  "        }",
		  "    }",
		  "    // Option : if u do sorting -> time complexity : O(sqrtN logN)",
		  "    // std::sort(divisors.begin(), divisors.end()); ",
		  "    return divisors;",
		  "}",
		  ""
		],
		"description": "enumerate divisors of n"
	},
	"irreducible fraction": {
		"prefix": "fraction",
		"body": [
		  "/* irreducible fraction class */",
		  "//  Operator:",
		  "//      +, -, *, /,",
		  "//      +=, -=, *=, /=,",
		  "//      =,",
		  "//      ==, !=, <, <=, >, >=,",
		  "//      ostream<< : convert to long double and output",
		  "//",
		  "//  Method:",
		  "//      inverse() : swap numerator for denominator",
		  "// ",
		  "class Fraction {",
		  "  public:",
		  "    using i64 = int_fast64_t;",
		  "    i64 numerator, denominator;",
		  "    Fraction(i64 Numerator = 0, i64 Denomirator = 1): numerator(Numerator), denominator(Denomirator) {",
		  "        err_0_division();",
		  "        reduce();",
		  "    };",
		  "    void inline inverse() {",
		  "        i64 tmp = denominator;",
		  "        denominator = numerator;",
		  "        numerator = tmp;",
		  "    }",
		  "    long double inline convert() noexcept { return (long double)numerator/(long double)denominator; }",
		  "",
		  "    friend std::ostream &operator<<(std::ostream &os, const Fraction &F) {",
		  "        Fraction tmp = F;",
		  "        return os << tmp.convert();",
		  "    }",
		  "    inline bool operator == (const Fraction &F) const noexcept {",
		  "        return numerator == F.numerator && denominator == F.denominator;",
		  "    }",
		  "    inline bool operator != (const Fraction &F) const noexcept {",
		  "        return !(*this==F);",
		  "    }",
		  "    inline bool operator <= (const Fraction &F) const noexcept {",
		  "        Fraction slf = *this, tmp = F;",
		  "        return slf.convert() < tmp.convert() || *this==F;",
		  "    }",
		  "    inline bool operator >= (const Fraction &F) const noexcept {",
		  "        Fraction slf = *this, tmp = F;",
		  "        return slf.convert() > tmp.convert() || *this==F;",
		  "    }",
		  "    inline bool operator < (const Fraction &F) const noexcept {",
		  "        return !(*this>=F);",
		  "    }",
		  "    inline bool operator > (const Fraction &F) const noexcept {",
		  "        return !(*this<=F);",
		  "    }",
		  "    Fraction operator + (const Fraction F) noexcept { return Fraction(*this) += F;}",
		  "    Fraction operator - (const Fraction F) noexcept { return Fraction(*this) -= F;}",
		  "    Fraction operator * (const Fraction F) noexcept { return Fraction(*this) *= F;}",
		  "    Fraction operator / (const Fraction F) noexcept { return Fraction(*this) /= F;}",
		  "    Fraction &operator = (const std::pair<i64, i64> P) noexcept {",
		  "        std::tie(numerator, denominator) = P;",
		  "        err_0_division();",
		  "        reduce();",
		  "        return *this;",
		  "    }",
		  "    Fraction &operator = (const Fraction F) noexcept {",
		  "        numerator = F.numerator, denominator = F.denominator;",
		  "        return *this;",
		  "    }",
		  "    Fraction &operator += (const Fraction F) noexcept {",
		  "        i64 g = GCD(denominator, F.denominator);",
		  "        numerator = numerator * (F.denominator/g) + F.numerator * (denominator/g);",
		  "        denominator = denominator/g * F.denominator;",
		  "        reduce();",
		  "        return *this;",
		  "    }",
		  "    Fraction &operator -= (const Fraction F) noexcept {",
		  "        i64 g = GCD(denominator, F.denominator);",
		  "        numerator = numerator * (F.denominator/g) - F.numerator * (denominator/g);",
		  "        denominator = denominator/g * F.denominator;",
		  "        reduce();",
		  "        return *this;",
		  "    }",
		  "    Fraction &operator *= (const Fraction F) noexcept {",
		  "        i64 g1 = GCD(numerator, F.denominator);",
		  "        i64 g2 = GCD(F.numerator, denominator);",
		  "        numerator = (numerator/g1) * (F.numerator/g2);",
		  "        denominator = (denominator/g2) * (F.denominator/g1);",
		  "        reduce();",
		  "        return *this;",
		  "    }",
		  "    Fraction &operator /= (const Fraction F) noexcept {",
		  "        Fraction f = F;",
		  "        f.inverse();",
		  "        *this *= f;",
		  "        reduce();",
		  "        return *this;",
		  "    }",
		  "  private:",
		  "    static i64 inline GCD(i64 a, i64 b) { return (b ? GCD(b, a%b) : a); }",
		  "    void inline reduce() noexcept {",
		  "        i64 g = GCD(std::abs(numerator), std::abs(denominator));",
		  "        numerator /= g;",
		  "        denominator /= g;",
		  "        // numerator > 0 && denominator < 0",
		  "        // or",
		  "        // numerator < 0 && denominator < 0",
		  "        // -> inverse sign",
		  "        if(denominator < 0) {",
		  "            numerator *= -1, denominator *= -1;",
		  "        }",
		  "    }",
		  "    void inline err_0_division() noexcept {",
		  "        if(denominator==0) std::abort();",
		  "    }",
		  "};",
		  ""
		],
		"description": "irreducible fraction"
	},
	"fast fourier transform and convolution": {
		"prefix": "fft_and_convolution",
		"body": [
		  "namespace FastFourierTransform {",
		  "    long double Pi = std::acos(-1.0L);",
		  "",
		  "    std::vector<std::complex<long double>> rec_fft(std::vector<std::complex<long double>> f, bool inverse=false) {",
		  "        if(f.size() == 1) {",
		  "            return std::vector<std::complex<long double>>(1, f[0]);",
		  "        }",
		  "        int N = f.size();",
		  "        std::vector<std::complex<long double>> f_e, f_o, F_e, F_o, F(N);",
		  "        for(int i = 0; i < N; ++i) {",
		  "            if(i&1) f_o.push_back(f[i]);",
		  "            else f_e.push_back(f[i]);",
		  "        }",
		  "        F_e = rec_fft(f_e, inverse);",
		  "        F_o = rec_fft(f_o, inverse);",
		  "",
		  "        std::complex<long double> w = 1, pow(std::cos(Pi/(N>>1)), std::sin(Pi/(N>>1)) * (inverse? 1 : -1));",
		  "        for(int i = 0; i < N/2; ++i, w *= pow) {",
		  "            F[i] = F_e[i] + w * F_o[i];",
		  "            F[i+N/2] = F_e[i] - w * F_o[i];",
		  "        }",
		  "        return F;",
		  "    }",
		  "",
		  "    std::vector<std::complex<long double>> fft(std::vector<std::complex<long double>> f) {",
		  "        int p_of_2 = 1;",
		  "        while(f.size() > p_of_2) p_of_2 <<= 1;",
		  "        while(p_of_2 > f.size()) f.emplace_back(0, 0);",
		  "        return rec_fft(std::move(f));",
		  "    }",
		  "    std::vector<std::complex<long double>> fft_inv(std::vector<std::complex<long double>> f) {",
		  "        int p_of_2 = 1;",
		  "        while(f.size() > p_of_2) p_of_2 <<= 1;",
		  "        while(p_of_2 > f.size()) f.emplace_back(0, 0);",
		  "        std::vector<std::complex<long double>> ret = rec_fft(std::move(f), true);",
		  "        for(auto &val : ret) val /= (long double)(ret.size());",
		  "        return ret;",
		  "    }",
		  "",
		  "    template<class T = int_fast32_t, class U, class V>",
		  "    std::vector<T> convolution(std::vector<U> f, std::vector<V> g, bool Round = std::is_integral<T>::value) {",
		  "        int n = f.size() + g.size() - 1;",
		  "        int p_of_2 = 1;",
		  "        while(n > p_of_2) p_of_2 <<= 1;",
		  "        while(p_of_2 > f.size()) f.push_back(0);",
		  "        while(p_of_2 > g.size()) g.push_back(0);",
		  "",
		  "        std::vector<std::complex<long double>> f_complex, g_complex, F, G, RES, res_complex;",
		  "        for(auto &val : f) f_complex.emplace_back(val, 0);",
		  "        for(auto &val : g) g_complex.emplace_back(val, 0);",
		  "        F = fft(f_complex), G = fft(g_complex);",
		  "",
		  "        for(int i = 0; i < p_of_2; ++i) RES.push_back(F[i] * G[i]);",
		  "        res_complex = fft_inv(RES);",
		  "        std::vector<T> res(res_complex.size());",
		  "        for(int i = 0; i < res.size(); ++i) res[i] = (Round? std::round(res_complex[i].real()) : res_complex[i].real());",
		  "        return res;",
		  "    }",
		  "}",
		  ""
		],
		"description": "fast fourier transform and convolution"
	},
	"square matrix class": {
		"prefix": "matrix_square",
		"body": [
		  "/* SquareMatrix */",
		  "// Operators",
		  "// +(SquareMatrix), -(SquareMatrix), *(SquareMatrix), *(T), *(std::vector<T>)",
		  "// +=(SquareMatrix), -=(SquareMatrix), *=(SquareMatrix), *=(T)",
		  "// [](std::size_t), [][](std::size_t)",
		  "// os<<",
		  "//",
		  "// Methods",
		  "// pow(i32) -> SquareMatrix, size() -> std::size_t",
		  "//",
		  "template <class T> class SquareMatrix {",
		  "    using Vec = std::vector<T>;",
		  "    using VecVec = std::vector<Vec>;",
		  "  public:",
		  "    constexpr SquareMatrix(std::size_t n) noexcept : mat(VecVec(n, Vec(n))) {}",
		  "    constexpr SquareMatrix(std::size_t n, T init) noexcept : mat(VecVec(n, Vec(n, init))) {}",
		  "",
		  "    friend std::ostream &operator<<(std::ostream& os, const SquareMatrix& m) {",
		  "        std::size_t i = 0;",
		  "        for (const auto& v : m.mat) {",
		  "            os << (i++ == 0 ? \"[[\" : \" [\");",
		  "            std::size_t j = 0;",
		  "            for (const auto& n : v) os << n << (++j == v.size() ? ']' : ' ');",
		  "            os << (i == m.mat.size() ? \"]\\n\" : \"\\n\");",
		  "        }",
		  "        return os;",
		  "    }",
		  "",
		  "    auto& operator[](std::size_t idx) & { return mat[idx]; }",
		  "    const auto& operator[](std::size_t idx) const& { return mat[idx]; }",
		  "    auto operator[](std::size_t idx) const&& noexcept { return std::move(mat[idx]); }",
		  "",
		  "    constexpr SquareMatrix operator+(const SquareMatrix m) const { return SquareMatrix(*this) += m; }",
		  "    constexpr SquareMatrix operator-(const SquareMatrix m) const { return SquareMatrix(*this) -= m; }",
		  "    constexpr SquareMatrix operator*(const SquareMatrix m) const { return SquareMatrix(*this) *= m; }",
		  "    constexpr SquareMatrix operator*(const T c) const noexcept { return SquareMatrix(*this) *= c; }",
		  "    constexpr SquareMatrix& operator+=(const SquareMatrix m) {",
		  "        assert(size() == m.size());",
		  "        for (std::size_t i = 0; i < size(); ++i) {",
		  "            for (std::size_t j = 0; j < size(); ++j) {",
		  "                mat[i][j] += m.mat[i][j];",
		  "            }",
		  "        }",
		  "        return *this;",
		  "    }",
		  "    constexpr SquareMatrix& operator-=(const SquareMatrix m) {",
		  "        assert(size() == m.size());",
		  "        for (std::size_t i = 0; i < size(); ++i) {",
		  "            for (std::size_t j = 0; j < size(); ++j) {",
		  "                mat[i][j] -= m.mat[i][j];",
		  "            }",
		  "        }",
		  "        return *this;",
		  "    }",
		  "    constexpr SquareMatrix& operator*=(const SquareMatrix m) {",
		  "        assert(size() == m.size());",
		  "        VecVec ret(size(), Vec(size()));",
		  "        for (std::size_t i = 0; i < size(); ++i) {",
		  "            for (std::size_t j = 0; j < size(); ++j) {",
		  "                for (std::size_t k = 0; k < size(); ++k) {",
		  "                    ret[i][j] += mat[i][k] * m.mat[k][j];",
		  "                }",
		  "            }",
		  "        }",
		  "        mat = std::move(ret);",
		  "        return *this;",
		  "    }",
		  "    constexpr SquareMatrix& operator*=(const T c) noexcept {",
		  "        for (std::size_t i = 0; i < size(); ++i) {",
		  "            for (std::size_t j = 0; j < size(); ++j) {",
		  "                mat[i][j] *= c;",
		  "            }",
		  "        }",
		  "        return *this;",
		  "    }",
		  "",
		  "    constexpr Vec operator*(const Vec v) const {",
		  "        assert(size() == v.size());",
		  "        Vec ret(size());",
		  "        for (std::size_t i = 0; i < size(); ++i) {",
		  "            for (std::size_t j = 0; j < size(); ++j) {",
		  "                ret[i] += mat[i][j] * v[j];",
		  "            }",
		  "        }",
		  "        return ret;",
		  "    }",
		  "",
		  "    constexpr SquareMatrix pow(std::int_fast32_t n) noexcept {",
		  "        SquareMatrix ret = SquareMatrix::make_id(size());",
		  "        SquareMatrix a(*this);",
		  "        while (n > 0) {",
		  "            if (n & 1) ret *= a;",
		  "            a = a * a, n >>= 1;",
		  "        }",
		  "        return ret;",
		  "    }",
		  "",
		  "    std::size_t size() const noexcept { return mat.size(); }",
		  "",
		  "    constexpr static SquareMatrix make_id(std::size_t n) noexcept {",
		  "        SquareMatrix mt(n);",
		  "        for (std::size_t i = 0; i < n; ++i) {",
		  "            mt[i][i] = 1;",
		  "        }",
		  "        return mt;",
		  "    }",
		  "  private:",
		  "    VecVec mat;",
		  "};",
		  "using MI = SquareMatrix<std::int_fast32_t>;",
		  ""
		],
		"description": "square matrix class"
	}
}