{
	// Place your competition_cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"calculate GCD": {
		"prefix": "gcd",
		"body": [
		  "/* GCD (Greatest Common Divisor) */",
		  "// calculate GCD",
		  "//",
		  "int_fast64_t GCD(int_fast64_t a, int_fast64_t b) {",
		  "    return (b ? GCD(b, a%b) : a);",
		  "}",
		  ""
		],
		"description": "calculate GCD"
	},
	"calculate LCM": {
		"prefix": "lcm",
		"body": [
		  "/* LCM (Least Common Multiple) */",
		  "// calculate LCM",
		  "//",
		  "int_fast64_t LCM(int_fast64_t a, int_fast64_t b) {",
		  "    int_fast64_t g = GCD(a, b);",
		  "    return (a/g) * (b/g) * g;",
		  "}",
		  ""
		],
		"description": "calculate LCM"
	},
	"ModInt": {
		"prefix": "mod_int",
		"body": [
		  "/* ModInt */",
		  "// Operators",
		  "// +, -, *, /, =, ==, !=,",
		  "// +=, -=, *=, /=",
		  "//",
		  "template<std::int_fast64_t Mod>",
		  "class ModInt {",
		  "  public:",
		  "    using i64 = std::int_fast64_t;",
		  "    i64 val;",
		  "    // constructor",
		  "    constexpr ModInt(const i64 p=0) noexcept : val(p>=0 ? p%Mod : (Mod+(p%Mod))%Mod) {}",
		  "",
		  "    // std::cin, std::cout",
		  "    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) {",
		  "        return os << x.val;",
		  "    }",
		  "    friend std::istream &operator>>(std::istream &is, ModInt &x) {",
		  "        is >> x.val;",
		  "        x.val %= Mod;",
		  "        if(x.val < 0) x.val += Mod;  // <- 負数対応",
		  "        return is;",
		  "    }",
		  "",
		  "    //operator",
		  "    constexpr ModInt operator+(const ModInt b) const noexcept { return ModInt(*this) += b; }",
		  "",
		  "    constexpr ModInt operator-(const ModInt b) const noexcept { return ModInt(*this) -= b; }",
		  "",
		  "    constexpr ModInt operator*(const ModInt b) const noexcept { return ModInt(*this) *= b; }",
		  "",
		  "    constexpr ModInt operator/(const ModInt b) const noexcept { return ModInt(*this) /= b; }",
		  "",
		  "    constexpr ModInt operator-() const noexcept { return ModInt() - *this; }",
		  "",
		  "    constexpr bool operator==(const ModInt &b) const noexcept { return this->val == b.val; }",
		  "",
		  "    constexpr bool operator!=(const ModInt &b) const noexcept { return this->val != b.val; }",
		  "",
		  "    constexpr ModInt &operator=(const ModInt b) noexcept {",
		  "        val = b.val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator=(const i64 b) noexcept {",
		  "        val = ModInt<Mod>(b).val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator+=(const ModInt b) noexcept {",
		  "        if((val += b.val) >= Mod) val -= Mod;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator-=(const ModInt b) noexcept {",
		  "        if(val < b.val) val += Mod;",
		  "        val -= b.val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator*=(const ModInt b) noexcept {",
		  "        val = val * b.val % Mod;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator/=(ModInt b) noexcept {",
		  "        val *= b.inverse().val;",
		  "        val %= Mod;",
		  "        return *this;",
		  "    }",
		  "    // calc val^n",
		  "    constexpr  ModInt pow(i64 n) noexcept {",
		  "        ModInt res = 1, a = val;",
		  "        while(n > 0) {",
		  "            if(n & 1) res = res * a;",
		  "            a = a * a;",
		  "            n >>= 1;",
		  "        }",
		  "        return res;",
		  "    }",
		  "  private:",
		  "    constexpr ModInt inverse() noexcept {",
		  "        i64 m=Mod, u=1, v=0, t=1;",
		  "        while(m) {",
		  "            t = val/m;",
		  "            val -= t*m; std::swap(val,m);",
		  "            u -= t*v; std::swap(u,v);",
		  "        }",
		  "        return ModInt(u);",
		  "    }",
		  "};",
		  "const int mod = 1000000007;",
		  "// const int mod = 998244353;",
		  "using mint = ModInt<mod>;",
		  ""
		],
		"description": "ModInt"
	},
	"Binomial": {
		"prefix": "binomial",
		"body": [
		  "/* Binomial (mod) */",
		  "// ",
		  "class Binomial {",
		  "  public:",
		  "    Binomial(int MAX = 510000, int MOD = 1000000007): MAX(MAX), MOD(MOD)",
		  "    {",
		  "        fac.resize(MAX);",
		  "        finv.resize(MAX);",
		  "        inv.resize(MAX);",
		  "        // Build 'binomial-table'",
		  "        fac[0] = fac[1] = 1;",
		  "        finv[0] = finv[1] = 1;",
		  "        inv[1] = 1;",
		  "        for (int i = 2; i < MAX; i++){",
		  "            fac[i] = fac[i - 1] * i % MOD;",
		  "            inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
		  "            finv[i] = finv[i - 1] * inv[i] % MOD;",
		  "        }",
		  "    }",
		  "",
		  "    // calculate Binomial(n, k) % MOD",
		  "    long long calc(int n, int k){",
		  "        if (n < k) return 0;",
		  "        if (n < 0 || k < 0) return 0;",
		  "        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
		  "    }",
		  "",
		  "  private:",
		  "    const int MAX;",
		  "    const int MOD;",
		  "    std::vector<long long> fac, finv, inv;",
		  "};",
		  ""
		],
		"description": "Binomial"
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve_of_eratosthenes",
		"body": [
		  "/* Sieve of Eratosthenes */",
		  "// detect prime numbers lower than MAX_N",
		  "// time complexity : O(N loglogN)",
		  "//",
		  "// Methods",
		  "// 1. is_prime(i64 n) -> bool : judge whether n is prime number",
		  "//",
		  "// Example",
		  "// constexpr size_t n = 1e7;",
		  "// Sieve<n> sieve; sieve.is_prime(157);",
		  "//",
		  "template<size_t MAX_N>",
		  "class Sieve {",
		  "  public:",
		  "    using i64 = int_fast64_t;",
		  "",
		  "    constexpr Sieve(): container() {",
		  "        for(i64 i = 1; i < (MAX_N+11)/6; ++i) {",
		  "            container[i][0] = container[i][1] = true;",
		  "        }",
		  "",
		  "        for(i64 i = 1; i < (MAX_N+11)/6; ++i) {",
		  "            if(container[i][0]) {  // 6i - 1 is prime",
		  "                for(i64 p = 1; p < (MAX_N+11)/6; ++p) {",
		  "                    i64 idx1 = 6*i*p + i - p;",
		  "                    i64 idx2 = 6*i*p - i - p;",
		  "                    if(idx2 >= (MAX_N+11)/6) break;",
		  "                    container[idx2][1] = false;",
		  "                    if(idx1 >= (MAX_N+11)/6) continue;",
		  "                    container[idx1][0] = false;",
		  "                }",
		  "            }",
		  "            if(container[i][1]) {  // 6i + 1 is prime",
		  "                for(i64 p = 1; p < (MAX_N+11)/6; ++p) {",
		  "                    i64 idx1 = 6*i*p + i + p;",
		  "                    i64 idx2 = 6*i*p - i + p;",
		  "                    if(idx2 >= (MAX_N+11)/6) break;",
		  "                    container[idx2][0] = false;",
		  "                    if(idx1 >= (MAX_N+11)/6) continue;",
		  "                    container[idx1][1] = false;",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    bool is_prime(i64 num) {  // num > 0",
		  "        if(num == 2 || num == 3) return true;",
		  "        if((num+1)%6 == 0) return (container[(num+1)/6][0]);",
		  "        if((num-1)%6 == 0) return (container[(num-1)/6][1]);",
		  "        return false;",
		  "    }",
		  "",
		  "  private:",
		  "    bool container[(MAX_N+11)/6][2];",
		  "};",
		  ""
		],
		"description": "Sieve of Eratosthenes"
	},
	"Prime Factorization": {
		"prefix": "prime_factorization",
		"body": [
		  "/* Prime Factorization */",
		  "// time complexity : O(sqrtN)",
		  "template<typename T_n>",
		  "std::map<T_n, int> prime_factor(T_n n) {",
		  "    std::map<T_n, int> ret;",
		  "    for(T_n i = 2; i*i <= n; i++){",
		  "        while(n % i == 0){",
		  "            ret[i]++;",
		  "            n /= i;",
		  "        }",
		  "    }",
		  "    if(n != 1) ret[n] = 1;",
		  "    return ret;",
		  "}",
		  "",
		  "/* Prime Factorization with preprocessing */",
		  "// time complexity (preprocessing) : O(N loglogN)",
		  "// time complexity (query) : O(logN)",
		  "template<size_t MAX_N>",
		  "class PrimeFactorization {",
		  "  public:",
		  "    using i64 = int_fast64_t;",
		  "    constexpr PrimeFactorization()",
		  "        : smallest_prime_factors() {",
		  "        for(i64 i = 0; i <= MAX_N; ++i) {",
		  "            smallest_prime_factors[i] = i;",
		  "        }",
		  "        for(i64 i = 2; i * i <= MAX_N; ++i) {",
		  "            if(smallest_prime_factors[i] == i) {",
		  "                for(i64 j = i * i; j <= MAX_N; j += i) {",
		  "                    if(smallest_prime_factors[j] == j) {",
		  "                        smallest_prime_factors[j] = i;",
		  "                    }",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    std::map<i64, i64> factorize(i64 n) {",
		  "        std::map<i64, i64> primes_map;",
		  "        while(n != 1) {",
		  "            ++primes_map[smallest_prime_factors[n]];",
		  "            n /= smallest_prime_factors[n];",
		  "        }",
		  "        return primes_map;",
		  "    }",
		  "  private:",
		  "    int_fast64_t smallest_prime_factors[MAX_N+1];",
		  "};",
		  ""
		],
		"description": "Prime Factorization"
	},
	"judge whether n is prime number or not": {
		"prefix": "is_prime",
		"body": [
		  "/* prime number judge */",
		  "// judge whether n is prime number or not",
		  "//",
		  "// Parameters",
		  "// 1. n (i32) : integer to be estimated",
		  "// ",
		  "// Returns",
		  "// 1. (bool) : is n prime number?",
		  "//",
		  "bool is_prime(int_fast32_t n) {",
		  "    if (n < 2) return false;",
		  "    else if (n == 2) return true;",
		  "    else if (n % 2 == 0) return false;",
		  "",
		  "    int_fast32_t sqrt_n = sqrt(n);",
		  "    for (int_fast32_t i = 3; i <= sqrt_n; i += 2){",
		  "        if (n % i == 0) return false;",
		  "    }",
		  "",
		  "    return true;",
		  "}",
		  ""
		],
		"description": "judge whether n is prime number or not"
	},
	"enumerate divisors of n": {
		"prefix": "enumerate_divisors",
		"body": [
		  "/* enumerate divisors */",
		  "// enumerate divisors of n",
		  "// time complexity : O(sqrtN)",
		  "//",
		  "// Parameters",
		  "// 1. n (i64) : targeted integer",
		  "// ",
		  "// Returns",
		  "// 1. divisors (vec<i64>) : divisors of n",
		  "//",
		  "std::vector<int_fast64_t> enumerate_divisors(int_fast64_t n) {",
		  "    std::vector<int_fast64_t> divisors;",
		  "    for (int_fast64_t i = 1; i * i <= n; i++) {",
		  "        if (n % i == 0) {",
		  "            divisors.push_back(i);",
		  "            if (i * i != n) divisors.push_back(n / i);",
		  "        }",
		  "    }",
		  "    // Option : if u do sorting -> time complexity : O(sqrtN logN)",
		  "    // std::sort(divisors.begin(), divisors.end()); ",
		  "    return divisors;",
		  "}",
		  ""
		],
		"description": "enumerate divisors of n"
	}
}