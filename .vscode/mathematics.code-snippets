{
	// Place your competition_cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"calculate GCD": {
		"prefix": "gcd",
		"body": [
		  "/* GCD (Greatest Common Divisor) */",
		  "// calculate GCD",
		  "//",
		  "int_fast64_t GCD(int_fast64_t a, int_fast64_t b) {",
		  "    return (b ? GCD(b, a%b) : a);",
		  "}",
		  ""
		],
		"description": "calculate GCD"
	},
	"calculate LCM": {
		"prefix": "lcm",
		"body": [
		  "/* LCM (Least Common Multiple) */",
		  "// calculate LCM",
		  "//",
		  "int_fast64_t LCM(int_fast64_t a, int_fast64_t b) {",
		  "    int_fast64_t g = GCD(a, b);",
		  "    return (a/g) * (b/g) * g;",
		  "}",
		  ""
		],
		"description": "calculate LCM"
	},
	"ModInt": {
		"prefix": "mod_int",
		"body": [
		  "/* ModInt */",
		  "// Operators",
		  "// +, -, *, /, =, ==, !=,",
		  "// +=, -=, *=, /=",
		  "//",
		  "template<std::int_fast64_t Mod>",
		  "class ModInt {",
		  "  public:",
		  "    using i64 = std::int_fast64_t;",
		  "    i64 val;",
		  "    // constructor",
		  "    constexpr ModInt(const i64 p=0) noexcept : val(p>=0 ? p%Mod : (Mod+(p%Mod))%Mod) {}",
		  "",
		  "    // std::cin, std::cout",
		  "    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) {",
		  "        return os << x.val;",
		  "    }",
		  "    friend std::istream &operator>>(std::istream &is, ModInt &x) {",
		  "        is >> x.val;",
		  "        x.val %= Mod;",
		  "        if(x.val < 0) x.val += Mod;  // <- 負数対応",
		  "        return is;",
		  "    }",
		  "",
		  "    //operator",
		  "    constexpr ModInt operator+(const ModInt b) const noexcept { return ModInt(*this) += b; }",
		  "",
		  "    constexpr ModInt operator-(const ModInt b) const noexcept { return ModInt(*this) -= b; }",
		  "",
		  "    constexpr ModInt operator*(const ModInt b) const noexcept { return ModInt(*this) *= b; }",
		  "",
		  "    constexpr ModInt operator/(const ModInt b) const noexcept { return ModInt(*this) /= b; }",
		  "",
		  "    constexpr ModInt operator-() const noexcept { return ModInt() - *this; }",
		  "",
		  "    constexpr bool operator==(const ModInt &b) const noexcept { return this->val == b.val; }",
		  "",
		  "    constexpr bool operator!=(const ModInt &b) const noexcept { return this->val != b.val; }",
		  "",
		  "    constexpr ModInt &operator=(const ModInt b) noexcept {",
		  "        val = b.val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator=(const i64 b) noexcept {",
		  "        val = ModInt<Mod>(b).val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator+=(const ModInt b) noexcept {",
		  "        if((val += b.val) >= Mod) val -= Mod;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator-=(const ModInt b) noexcept {",
		  "        if(val < b.val) val += Mod;",
		  "        val -= b.val;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator*=(const ModInt b) noexcept {",
		  "        val = val * b.val % Mod;",
		  "        return *this;",
		  "    }",
		  "    constexpr ModInt &operator/=(ModInt b) noexcept {",
		  "        val *= b.inverse().val;",
		  "        val %= Mod;",
		  "        return *this;",
		  "    }",
		  "    // calc val^n",
		  "    constexpr  ModInt pow(i64 n) noexcept {",
		  "        ModInt res = 1, a = val;",
		  "        while(n > 0) {",
		  "            if(n & 1) res = res * a;",
		  "            a = a * a;",
		  "            n >>= 1;",
		  "        }",
		  "        return res;",
		  "    }",
		  "  private:",
		  "    constexpr ModInt inverse() noexcept {",
		  "        i64 m=Mod, u=1, v=0, t=1;",
		  "        while(m) {",
		  "            t = val/m;",
		  "            val -= t*m; std::swap(val,m);",
		  "            u -= t*v; std::swap(u,v);",
		  "        }",
		  "        return ModInt(u);",
		  "    }",
		  "};",
		  "const int mod = 1000000007;",
		  "// const int mod = 998244353;",
		  "using mint = ModInt<mod>;",
		  ""
		],
		"description": "ModInt"
	},
	"Binomial": {
		"prefix": "binomial",
		"body": [
		  "/* Binomial (mod) */",
		  "// ",
		  "class Binomial {",
		  "  public:",
		  "    Binomial(int MAX = 510000, int MOD = 1000000007): MAX(MAX), MOD(MOD)",
		  "    {",
		  "        fac.resize(MAX);",
		  "        finv.resize(MAX);",
		  "        inv.resize(MAX);",
		  "        // Build 'binomial-table'",
		  "        fac[0] = fac[1] = 1;",
		  "        finv[0] = finv[1] = 1;",
		  "        inv[1] = 1;",
		  "        for (int i = 2; i < MAX; i++){",
		  "            fac[i] = fac[i - 1] * i % MOD;",
		  "            inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
		  "            finv[i] = finv[i - 1] * inv[i] % MOD;",
		  "        }",
		  "    }",
		  "",
		  "    // calculate Binomial(n, k) % MOD",
		  "    long long calc(int n, int k){",
		  "        if (n < k) return 0;",
		  "        if (n < 0 || k < 0) return 0;",
		  "        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
		  "    }",
		  "",
		  "  private:",
		  "    const int MAX;",
		  "    const int MOD;",
		  "    std::vector<long long> fac, finv, inv;",
		  "};",
		  ""
		],
		"description": "Binomial"
	}
}