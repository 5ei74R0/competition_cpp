{
	// Place your competition_cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"template of graph representation": {
		"prefix": "graph_template",
		"body": [
		  "/* template of graph representation */",
		  "// represent edge of weighted graph",
		  "template<typename T>",
		  "struct Edge {",
		  "    int_fast32_t src;  // idx of the source vertex",
		  "    int_fast32_t to;  // idx of the vertex this edge reaches",
		  "    T cost;  // weight",
		  "",
		  "    Edge(int_fast32_t to, T cost)",
		  "        : src(-1), to(t), cost(w) {}",
		  "    Edge(int_fast32_t src, int_fast32_t to, T cost)",
		  "        : src(src), to(to), cost(cost) {}",
		  "};",
		  "",
		  "template<typename T = int_fast32_t>",
		  "using GraphWeighted = std::vector<std::vector<Edge<T>>>;  // weighted graph",
		  "using Graph = std::vector<std::vector<int_fast32_t>>;  // graph",
		  "template<typename T = int_fast32_t>",
		  "using Matrix = std::vector<std::vector<T>>;  // adjacency matrix",
		  "",
		  ""
		],
		"description": "template of graph representation"
	},
	"dijkstra's algorithm to solve SSSP": {
		"prefix": "dijkstra",
		"body": [
		  "/* dijkstra's algorithm */",
		  "// calculate costs of SSSP (Single Source Shortest Path)",
		  "// time complexity : O((E + v)logV)",
		  "// ",
		  "// Parameters",
		  "// 1. graph (GraphWeighted) : weight of evey edge >= 0",
		  "// 2. start_vertex (i32) : idx of start_vertex",
		  "// Returns",
		  "// 1. min_dist (vec<T>) : min_dist[i] == cost of SSSP (start_vertex -> i)",
		  "template<class T>",
		  "std::vector<T> Dijkstra(const GraphWeighted<T> &graph, const int_fast32_t start_vertex) {",
		  "    constexpr auto infinity = std::numeric_limits<T>::max();",
		  "    std::vector<T> min_dist(graph.size(), infinity);",
		  "",
		  "    using P = std::pair<T, int_fast32_t>;  // std::pair< DistFromStartingVertex, IndexOfVertex >",
		  "    std::priority_queue<P, std::vector<P>, std::greater<P>> min_heap;",
		  "    min_dist[start_vertex] = 0;",
		  "    min_heap.emplace(min_dist[start_vertex], start_vertex);",
		  "",
		  "    while(!min_heap.empty()) {",
		  "        T dist;",
		  "        int_fast32_t index;",
		  "        tie(dist, index) = min_heap.top();",
		  "        min_heap.pop();",
		  "        if(dist > min_dist[index]) continue;",
		  "",
		  "        for(auto &edge : graph[index]) {",
		  "            auto new_dist = dist + edge.cost;",
		  "            // compare the length of each route and change min_dist[edge.to]",
		  "            if(new_dist >= min_dist[edge.to]) continue;",
		  "            min_dist[edge.to] = new_dist;",
		  "            min_heap.emplace(min_dist[edge.to], edge.to);",
		  "        }",
		  "    }",
		  "    return min_dist;",
		  "}",
		  ""
		],
		"description": "dijkstra's algorithm to solve SSSP"
	},
	"warshall-floyd's algorithm": {
		"prefix": "warshall_floyd",
		"body": [
		  "/* warshall-floyd's algorithm */",
		  "// calculate costs of APSP (All Pairs Shortest Path)",
		  "// time complexity : O(V^3)",
		  "//",
		  "// Parameters",
		  "// 1. graph (Matrix<T>) : the adjacency matrix of the weighted graph.",
		  "// 2. unconnected_param (T) : the value in adjacency matrix representing unconnected path",
		  "// Returns",
		  "// 1. costs (vector<vector<T>>) : 2d-array containing costs of APSP (costs[frm][to] == cost of \"frm -> to\")",
		  "template<class T>",
		  "std::vector<std::vector<T>> WarshallFloyd(const Matrix<T> &graph, T unconnected_param) {",
		  "    using i32 int_fast32_t;",
		  "    constexpr auto infinity = std::numeric_limits<T>::max();",
		  "    std::vector<std::vector<T>> costs;",
		  "    // init costs",
		  "    for (i32 i = 0; i < g.size(); ++i) {",
		  "        for (i32 j = 0; j < g.size(); ++j) {",
		  "            if (i == j) costs[i][j] = 0;",
		  "            else if (graph[i][j] == unconnected_param) costs[i][j] = infinity;",
		  "            else costs[i][j] = graph[i][j];",
		  "        }",
		  "    }",
		  "    // calc",
		  "    for (i32 inter = 0; inter < g.size(); ++inter) {",
		  "        for (i32 frm = 0; frm < g.size(); ++frm) {",
		  "            for (i32 to = 0; to < g.size(); ++to) {",
		  "                if (graph[frm][inter] == infinity ||",
		  "                    graph[inter][to] == infinity) {",
		  "                    continue;",
		  "                }",
		  "                graph[frm][to] = std::min<T>(graph[frm][to], graph[frm][inter] + graph[inter][to]);",
		  "            }",
		  "        }",
		  "    }",
		  "    return costs;",
		  "}",
		  ""
		],
		"description": "warshall-floyd's algorithm"
	}
}