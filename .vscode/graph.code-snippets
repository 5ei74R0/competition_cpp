{
	// Place your competition_cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"template of graph representation": {
		"prefix": "graph_template",
		"body": [
		  "/* template of graph representation */",
		  "// represent edge of weighted graph",
		  "template<typename T>",
		  "struct Edge {",
		  "    int_fast32_t src;  // idx of the source vertex",
		  "    int_fast32_t to;  // idx of the vertex this edge reaches",
		  "    T cost;  // weight",
		  "",
		  "    Edge(int_fast32_t to, T cost)",
		  "        : src(-1), to(to), cost(cost) {}",
		  "    Edge(int_fast32_t src, int_fast32_t to, T cost)",
		  "        : src(src), to(to), cost(cost) {}",
		  "};",
		  "",
		  "template<typename T = int_fast32_t>",
		  "using GraphWeighted = std::vector<std::vector<Edge<T>>>;  // weighted graph",
		  "using Graph = std::vector<std::vector<int_fast32_t>>;  // graph",
		  "template<typename T = int_fast32_t>",
		  "using Matrix = std::vector<std::vector<T>>;  // adjacency matrix",
		  "",
		  ""
		],
		"description": "template of graph representation"
	},
	"dijkstra's algorithm to solve SSSP": {
		"prefix": "dijkstra",
		"body": [
		  "/* dijkstra's algorithm */",
		  "// calculate costs of SSSP (Single Source Shortest Path)",
		  "// time complexity : O((E + v)logV)",
		  "// ",
		  "// Parameters",
		  "// 1. graph (GraphWeighted) : weight of evey edge >= 0",
		  "// 2. start_vertex (i32) : idx of start_vertex",
		  "// Returns",
		  "// 1. min_dist (vec<T>) : min_dist[i] == cost of SSSP (start_vertex -> i)",
		  "template<class T>",
		  "std::vector<T> Dijkstra(const GraphWeighted<T> &graph, const int_fast32_t start_vertex) {",
		  "    constexpr auto infinity = std::numeric_limits<T>::max();",
		  "    std::vector<T> min_dist(graph.size(), infinity);",
		  "",
		  "    using P = std::pair<T, int_fast32_t>;  // std::pair< DistFromStartingVertex, IndexOfVertex >",
		  "    std::priority_queue<P, std::vector<P>, std::greater<P>> min_heap;",
		  "    min_dist[start_vertex] = 0;",
		  "    min_heap.emplace(min_dist[start_vertex], start_vertex);",
		  "",
		  "    while(!min_heap.empty()) {",
		  "        T dist;",
		  "        int_fast32_t index;",
		  "        tie(dist, index) = min_heap.top();",
		  "        min_heap.pop();",
		  "        if(dist > min_dist[index]) continue;",
		  "",
		  "        for(auto &edge : graph[index]) {",
		  "            auto new_dist = dist + edge.cost;",
		  "            // compare the length of each route and change min_dist[edge.to]",
		  "            if(new_dist >= min_dist[edge.to]) continue;",
		  "            min_dist[edge.to] = new_dist;",
		  "            min_heap.emplace(min_dist[edge.to], edge.to);",
		  "        }",
		  "    }",
		  "    return min_dist;",
		  "}",
		  ""
		],
		"description": "dijkstra's algorithm to solve SSSP"
	},
	"warshall-floyd's algorithm": {
		"prefix": "warshall_floyd",
		"body": [
		  "/* warshall-floyd's algorithm */",
		  "// calculate costs of APSP (All Pairs Shortest Path)",
		  "// time complexity : O(V^3)",
		  "//",
		  "// Parameters",
		  "// 1. graph (Matrix<T>) : the adjacency matrix of the weighted graph.",
		  "// 2. unconnected_param (T) : the value in adjacency matrix representing unconnected path",
		  "// Returns",
		  "// 1. costs (vector<vector<T>>)",
		  "// : 2d-array containing costs of APSP",
		  "//   (costs[frm][to] == cost of \"frm -> to\")",
		  "//   if there is a negative cycle include \"k\", then costs[k][k] < 0",
		  "template<class T>",
		  "std::vector<std::vector<T>> WarshallFloyd(const Matrix<T> &graph, T unconnected_param) {",
		  "    using i32 = int_fast32_t;",
		  "    constexpr auto infinity = std::numeric_limits<T>::max();",
		  "    std::vector<std::vector<T>> costs = graph;",
		  "    // init costs",
		  "    for (i32 i = 0; i < graph.size(); ++i) {",
		  "        for (i32 j = 0; j < graph.size(); ++j) {",
		  "            if (graph[i][j] == unconnected_param) costs[i][j] = infinity;",
		  "            else costs[i][j] = graph[i][j];",
		  "        }",
		  "    }",
		  "    // calc",
		  "    for (i32 inter = 0; inter < costs.size(); ++inter) {",
		  "        for (i32 frm = 0; frm < costs.size(); ++frm) {",
		  "            for (i32 to = 0; to < costs.size(); ++to) {",
		  "                if (costs[frm][inter] == infinity ||",
		  "                    costs[inter][to] == infinity) {",
		  "                    continue;",
		  "                }",
		  "                costs[frm][to] = std::min<T>(costs[frm][to], costs[frm][inter] + costs[inter][to]);",
		  "            }",
		  "        }",
		  "    }",
		  "    return costs;",
		  "}",
		  ""
		],
		"description": "warshall-floyd's algorithm"
	},
	"LowLink. detect bridges or articulation points": {
		"prefix": "lowlink",
		"body": [
		  "/* lowlink */",
		  "// detect bridges or articulation points",
		  "// time complexity : O(V + E)",
		  "//",
		  "// Attributes",
		  "// 1. articulation_points (vector<i32>) : list of articulation points",
		  "// 2. bridges (vector<pair<i32, i32>>) : list of bridges",
		  "// Methods",
		  "// 1. build : build lowlink. (use at 1st)",
		  "class LowLink {",
		  "  public:",
		  "    using i32 = int_fast32_t;",
		  "    std::vector<i32> articulation_points;",
		  "    std::vector<std::pair<i32, i32>> bridges;",
		  "    explicit LowLink(const Graph &graph)",
		  "        : order(graph.size()),",
		  "          low(graph.size()),",
		  "          seen(graph.size()),",
		  "          graph(graph) {}",
		  "",
		  "    void build() {",
		  "        InnerDfs();",
		  "    }",
		  "",
		  "  private:",
		  "    const std::vector<std::vector<i32>> &graph;",
		  "    std::vector<bool> seen;",
		  "    // order (vector<i32>) : order[vertex] = order in DFS",
		  "    std::vector<i32> order;",
		  "    // low (vector<i32>) : low[vertex] = minimum number of order[v] for all v connected to vertex",
		  "    std::vector<i32> low;",
		  "",
		  "    // decide order[vertex] and low[vertex]",
		  "    // detail : decide order \"top-down\" -> decide low \"bottom-up\"",
		  "    i32 InnerDfs(i32 vertex = 0, i32 past_v = -1, i32 k = 0) {",
		  "        seen[vertex] = true;",
		  "        order[vertex] = k;",
		  "",
		  "        // decide low[vertex] and judge whether vertex is articulation point",
		  "        bool is_articulation_point = false;",
		  "        low[vertex] = order[vertex];",
		  "        for (const auto &next_v : graph[vertex]) {",
		  "            if (!seen[next_v]) {",
		  "                k = InnerDfs(next_v, vertex, k+1);",
		  "                low[vertex] = std::min(low[vertex], low[next_v]);",
		  "                if (k != 1 && order[vertex] <= low[vertex]) {",
		  "                    is_articulation_point = true;",
		  "                }",
		  "                if (order[vertex] < low[next_v]) {",
		  "                    bridges.emplace_back(std::min(vertex, next_v), std::max(vertex, next_v));",
		  "                }",
		  "            }",
		  "            else if (next_v != past_v) {  // back edge",
		  "                low[vertex] = std::min(low[vertex], order[next_v]);",
		  "            }",
		  "        }",
		  "        if (k == 1 && graph[order[0]].size() > 1) is_articulation_point = true;",
		  "        if(is_articulation_point) articulation_points.push_back(vertex);",
		  "        return k;",
		  "    }",
		  "};",
		  ""
		],
		"description": "LowLink. detect bridges or articulation points"
	  }
}